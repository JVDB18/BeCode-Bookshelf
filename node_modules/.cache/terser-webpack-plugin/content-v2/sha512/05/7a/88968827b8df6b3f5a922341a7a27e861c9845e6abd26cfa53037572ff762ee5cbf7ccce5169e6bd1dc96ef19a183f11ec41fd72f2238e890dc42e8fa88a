{"map":"{\"version\":3,\"sources\":[\"/Users/icomputer/Documents/GitHub/BeCode-Bookshelf/node_modules/history/es/createBrowserHistory.js\",\"/Users/icomputer/Documents/GitHub/BeCode-Bookshelf/node_modules/history/es/createHashHistory.js\"],\"names\":[\"warning__WEBPACK_IMPORTED_MODULE_0__\",\"__webpack_require__\",\"warning__WEBPACK_IMPORTED_MODULE_0___default\",\"n\",\"invariant__WEBPACK_IMPORTED_MODULE_1__\",\"invariant__WEBPACK_IMPORTED_MODULE_1___default\",\"_LocationUtils__WEBPACK_IMPORTED_MODULE_2__\",\"_PathUtils__WEBPACK_IMPORTED_MODULE_3__\",\"_createTransitionManager__WEBPACK_IMPORTED_MODULE_4__\",\"_DOMUtils__WEBPACK_IMPORTED_MODULE_5__\",\"_typeof\",\"Symbol\",\"iterator\",\"obj\",\"constructor\",\"prototype\",\"_extends\",\"Object\",\"assign\",\"target\",\"i\",\"arguments\",\"length\",\"source\",\"key\",\"hasOwnProperty\",\"call\",\"getHistoryState\",\"window\",\"history\",\"state\",\"e\",\"__webpack_exports__\",\"props\",\"undefined\",\"globalHistory\",\"canUseHistory\",\"needsHashChangeListener\",\"_props$forceRefresh\",\"forceRefresh\",\"_props$getUserConfirm\",\"getUserConfirmation\",\"_props$keyLength\",\"keyLength\",\"basename\",\"getDOMLocation\",\"historyState\",\"_ref\",\"_window$location\",\"location\",\"path\",\"pathname\",\"search\",\"hash\",\"createKey\",\"Math\",\"random\",\"toString\",\"substr\",\"transitionManager\",\"setState\",\"nextState\",\"notifyListeners\",\"action\",\"handlePopState\",\"event\",\"handlePop\",\"handleHashChange\",\"forceNextPop\",\"confirmTransitionTo\",\"ok\",\"revertPop\",\"fromLocation\",\"toLocation\",\"toIndex\",\"allKeys\",\"indexOf\",\"fromIndex\",\"delta\",\"go\",\"initialLocation\",\"createHref\",\"listenerCount\",\"checkDOMListeners\",\"isBlocked\",\"push\",\"href\",\"pushState\",\"prevIndex\",\"nextKeys\",\"slice\",\"replace\",\"replaceState\",\"goBack\",\"goForward\",\"block\",\"prompt\",\"unblock\",\"setPrompt\",\"listen\",\"listener\",\"unlisten\",\"appendListener\"],\"mappings\":\"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\",\"sourcesContent\":[\"var _typeof = typeof Symbol === \\\"function\\\" && typeof Symbol.iterator === \\\"symbol\\\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \\\"function\\\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \\\"symbol\\\" : typeof obj; };\\n\\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\\n\\nimport warning from 'warning';\\nimport invariant from 'invariant';\\nimport { createLocation } from './LocationUtils';\\nimport { addLeadingSlash, stripTrailingSlash, hasBasename, stripBasename, createPath } from './PathUtils';\\nimport createTransitionManager from './createTransitionManager';\\nimport { canUseDOM, addEventListener, removeEventListener, getConfirmation, supportsHistory, supportsPopStateOnHashChange, isExtraneousPopstateEvent } from './DOMUtils';\\n\\nvar PopStateEvent = 'popstate';\\nvar HashChangeEvent = 'hashchange';\\n\\nvar getHistoryState = function getHistoryState() {\\n  try {\\n    return window.history.state || {};\\n  } catch (e) {\\n    // IE 11 sometimes throws when accessing window.history.state\\n    // See https://github.com/ReactTraining/history/pull/289\\n    return {};\\n  }\\n};\\n\\n/**\\n * Creates a history object that uses the HTML5 history API including\\n * pushState, replaceState, and the popstate event.\\n */\\nvar createBrowserHistory = function createBrowserHistory() {\\n  var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\\n\\n  invariant(canUseDOM, 'Browser history needs a DOM');\\n\\n  var globalHistory = window.history;\\n  var canUseHistory = supportsHistory();\\n  var needsHashChangeListener = !supportsPopStateOnHashChange();\\n\\n  var _props$forceRefresh = props.forceRefresh,\\n      forceRefresh = _props$forceRefresh === undefined ? false : _props$forceRefresh,\\n      _props$getUserConfirm = props.getUserConfirmation,\\n      getUserConfirmation = _props$getUserConfirm === undefined ? getConfirmation : _props$getUserConfirm,\\n      _props$keyLength = props.keyLength,\\n      keyLength = _props$keyLength === undefined ? 6 : _props$keyLength;\\n\\n  var basename = props.basename ? stripTrailingSlash(addLeadingSlash(props.basename)) : '';\\n\\n  var getDOMLocation = function getDOMLocation(historyState) {\\n    var _ref = historyState || {},\\n        key = _ref.key,\\n        state = _ref.state;\\n\\n    var _window$location = window.location,\\n        pathname = _window$location.pathname,\\n        search = _window$location.search,\\n        hash = _window$location.hash;\\n\\n\\n    var path = pathname + search + hash;\\n\\n    warning(!basename || hasBasename(path, basename), 'You are attempting to use a basename on a page whose URL path does not begin ' + 'with the basename. Expected path \\\"' + path + '\\\" to begin with \\\"' + basename + '\\\".');\\n\\n    if (basename) path = stripBasename(path, basename);\\n\\n    return createLocation(path, state, key);\\n  };\\n\\n  var createKey = function createKey() {\\n    return Math.random().toString(36).substr(2, keyLength);\\n  };\\n\\n  var transitionManager = createTransitionManager();\\n\\n  var setState = function setState(nextState) {\\n    _extends(history, nextState);\\n\\n    history.length = globalHistory.length;\\n\\n    transitionManager.notifyListeners(history.location, history.action);\\n  };\\n\\n  var handlePopState = function handlePopState(event) {\\n    // Ignore extraneous popstate events in WebKit.\\n    if (isExtraneousPopstateEvent(event)) return;\\n\\n    handlePop(getDOMLocation(event.state));\\n  };\\n\\n  var handleHashChange = function handleHashChange() {\\n    handlePop(getDOMLocation(getHistoryState()));\\n  };\\n\\n  var forceNextPop = false;\\n\\n  var handlePop = function handlePop(location) {\\n    if (forceNextPop) {\\n      forceNextPop = false;\\n      setState();\\n    } else {\\n      var action = 'POP';\\n\\n      transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {\\n        if (ok) {\\n          setState({ action: action, location: location });\\n        } else {\\n          revertPop(location);\\n        }\\n      });\\n    }\\n  };\\n\\n  var revertPop = function revertPop(fromLocation) {\\n    var toLocation = history.location;\\n\\n    // TODO: We could probably make this more reliable by\\n    // keeping a list of keys we've seen in sessionStorage.\\n    // Instead, we just default to 0 for keys we don't know.\\n\\n    var toIndex = allKeys.indexOf(toLocation.key);\\n\\n    if (toIndex === -1) toIndex = 0;\\n\\n    var fromIndex = allKeys.indexOf(fromLocation.key);\\n\\n    if (fromIndex === -1) fromIndex = 0;\\n\\n    var delta = toIndex - fromIndex;\\n\\n    if (delta) {\\n      forceNextPop = true;\\n      go(delta);\\n    }\\n  };\\n\\n  var initialLocation = getDOMLocation(getHistoryState());\\n  var allKeys = [initialLocation.key];\\n\\n  // Public interface\\n\\n  var createHref = function createHref(location) {\\n    return basename + createPath(location);\\n  };\\n\\n  var push = function push(path, state) {\\n    warning(!((typeof path === 'undefined' ? 'undefined' : _typeof(path)) === 'object' && path.state !== undefined && state !== undefined), 'You should avoid providing a 2nd state argument to push when the 1st ' + 'argument is a location-like object that already has state; it is ignored');\\n\\n    var action = 'PUSH';\\n    var location = createLocation(path, state, createKey(), history.location);\\n\\n    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {\\n      if (!ok) return;\\n\\n      var href = createHref(location);\\n      var key = location.key,\\n          state = location.state;\\n\\n\\n      if (canUseHistory) {\\n        globalHistory.pushState({ key: key, state: state }, null, href);\\n\\n        if (forceRefresh) {\\n          window.location.href = href;\\n        } else {\\n          var prevIndex = allKeys.indexOf(history.location.key);\\n          var nextKeys = allKeys.slice(0, prevIndex === -1 ? 0 : prevIndex + 1);\\n\\n          nextKeys.push(location.key);\\n          allKeys = nextKeys;\\n\\n          setState({ action: action, location: location });\\n        }\\n      } else {\\n        warning(state === undefined, 'Browser history cannot push state in browsers that do not support HTML5 history');\\n\\n        window.location.href = href;\\n      }\\n    });\\n  };\\n\\n  var replace = function replace(path, state) {\\n    warning(!((typeof path === 'undefined' ? 'undefined' : _typeof(path)) === 'object' && path.state !== undefined && state !== undefined), 'You should avoid providing a 2nd state argument to replace when the 1st ' + 'argument is a location-like object that already has state; it is ignored');\\n\\n    var action = 'REPLACE';\\n    var location = createLocation(path, state, createKey(), history.location);\\n\\n    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {\\n      if (!ok) return;\\n\\n      var href = createHref(location);\\n      var key = location.key,\\n          state = location.state;\\n\\n\\n      if (canUseHistory) {\\n        globalHistory.replaceState({ key: key, state: state }, null, href);\\n\\n        if (forceRefresh) {\\n          window.location.replace(href);\\n        } else {\\n          var prevIndex = allKeys.indexOf(history.location.key);\\n\\n          if (prevIndex !== -1) allKeys[prevIndex] = location.key;\\n\\n          setState({ action: action, location: location });\\n        }\\n      } else {\\n        warning(state === undefined, 'Browser history cannot replace state in browsers that do not support HTML5 history');\\n\\n        window.location.replace(href);\\n      }\\n    });\\n  };\\n\\n  var go = function go(n) {\\n    globalHistory.go(n);\\n  };\\n\\n  var goBack = function goBack() {\\n    return go(-1);\\n  };\\n\\n  var goForward = function goForward() {\\n    return go(1);\\n  };\\n\\n  var listenerCount = 0;\\n\\n  var checkDOMListeners = function checkDOMListeners(delta) {\\n    listenerCount += delta;\\n\\n    if (listenerCount === 1) {\\n      addEventListener(window, PopStateEvent, handlePopState);\\n\\n      if (needsHashChangeListener) addEventListener(window, HashChangeEvent, handleHashChange);\\n    } else if (listenerCount === 0) {\\n      removeEventListener(window, PopStateEvent, handlePopState);\\n\\n      if (needsHashChangeListener) removeEventListener(window, HashChangeEvent, handleHashChange);\\n    }\\n  };\\n\\n  var isBlocked = false;\\n\\n  var block = function block() {\\n    var prompt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\\n\\n    var unblock = transitionManager.setPrompt(prompt);\\n\\n    if (!isBlocked) {\\n      checkDOMListeners(1);\\n      isBlocked = true;\\n    }\\n\\n    return function () {\\n      if (isBlocked) {\\n        isBlocked = false;\\n        checkDOMListeners(-1);\\n      }\\n\\n      return unblock();\\n    };\\n  };\\n\\n  var listen = function listen(listener) {\\n    var unlisten = transitionManager.appendListener(listener);\\n    checkDOMListeners(1);\\n\\n    return function () {\\n      checkDOMListeners(-1);\\n      unlisten();\\n    };\\n  };\\n\\n  var history = {\\n    length: globalHistory.length,\\n    action: 'POP',\\n    location: initialLocation,\\n    createHref: createHref,\\n    push: push,\\n    replace: replace,\\n    go: go,\\n    goBack: goBack,\\n    goForward: goForward,\\n    block: block,\\n    listen: listen\\n  };\\n\\n  return history;\\n};\\n\\nexport default createBrowserHistory;\",\"var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\\n\\nimport warning from 'warning';\\nimport invariant from 'invariant';\\nimport { createLocation, locationsAreEqual } from './LocationUtils';\\nimport { addLeadingSlash, stripLeadingSlash, stripTrailingSlash, hasBasename, stripBasename, createPath } from './PathUtils';\\nimport createTransitionManager from './createTransitionManager';\\nimport { canUseDOM, addEventListener, removeEventListener, getConfirmation, supportsGoWithoutReloadUsingHash } from './DOMUtils';\\n\\nvar HashChangeEvent = 'hashchange';\\n\\nvar HashPathCoders = {\\n  hashbang: {\\n    encodePath: function encodePath(path) {\\n      return path.charAt(0) === '!' ? path : '!/' + stripLeadingSlash(path);\\n    },\\n    decodePath: function decodePath(path) {\\n      return path.charAt(0) === '!' ? path.substr(1) : path;\\n    }\\n  },\\n  noslash: {\\n    encodePath: stripLeadingSlash,\\n    decodePath: addLeadingSlash\\n  },\\n  slash: {\\n    encodePath: addLeadingSlash,\\n    decodePath: addLeadingSlash\\n  }\\n};\\n\\nvar getHashPath = function getHashPath() {\\n  // We can't use window.location.hash here because it's not\\n  // consistent across browsers - Firefox will pre-decode it!\\n  var href = window.location.href;\\n  var hashIndex = href.indexOf('#');\\n  return hashIndex === -1 ? '' : href.substring(hashIndex + 1);\\n};\\n\\nvar pushHashPath = function pushHashPath(path) {\\n  return window.location.hash = path;\\n};\\n\\nvar replaceHashPath = function replaceHashPath(path) {\\n  var hashIndex = window.location.href.indexOf('#');\\n\\n  window.location.replace(window.location.href.slice(0, hashIndex >= 0 ? hashIndex : 0) + '#' + path);\\n};\\n\\nvar createHashHistory = function createHashHistory() {\\n  var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\\n\\n  invariant(canUseDOM, 'Hash history needs a DOM');\\n\\n  var globalHistory = window.history;\\n  var canGoWithoutReload = supportsGoWithoutReloadUsingHash();\\n\\n  var _props$getUserConfirm = props.getUserConfirmation,\\n      getUserConfirmation = _props$getUserConfirm === undefined ? getConfirmation : _props$getUserConfirm,\\n      _props$hashType = props.hashType,\\n      hashType = _props$hashType === undefined ? 'slash' : _props$hashType;\\n\\n  var basename = props.basename ? stripTrailingSlash(addLeadingSlash(props.basename)) : '';\\n\\n  var _HashPathCoders$hashT = HashPathCoders[hashType],\\n      encodePath = _HashPathCoders$hashT.encodePath,\\n      decodePath = _HashPathCoders$hashT.decodePath;\\n\\n\\n  var getDOMLocation = function getDOMLocation() {\\n    var path = decodePath(getHashPath());\\n\\n    warning(!basename || hasBasename(path, basename), 'You are attempting to use a basename on a page whose URL path does not begin ' + 'with the basename. Expected path \\\"' + path + '\\\" to begin with \\\"' + basename + '\\\".');\\n\\n    if (basename) path = stripBasename(path, basename);\\n\\n    return createLocation(path);\\n  };\\n\\n  var transitionManager = createTransitionManager();\\n\\n  var setState = function setState(nextState) {\\n    _extends(history, nextState);\\n\\n    history.length = globalHistory.length;\\n\\n    transitionManager.notifyListeners(history.location, history.action);\\n  };\\n\\n  var forceNextPop = false;\\n  var ignorePath = null;\\n\\n  var handleHashChange = function handleHashChange() {\\n    var path = getHashPath();\\n    var encodedPath = encodePath(path);\\n\\n    if (path !== encodedPath) {\\n      // Ensure we always have a properly-encoded hash.\\n      replaceHashPath(encodedPath);\\n    } else {\\n      var location = getDOMLocation();\\n      var prevLocation = history.location;\\n\\n      if (!forceNextPop && locationsAreEqual(prevLocation, location)) return; // A hashchange doesn't always == location change.\\n\\n      if (ignorePath === createPath(location)) return; // Ignore this change; we already setState in push/replace.\\n\\n      ignorePath = null;\\n\\n      handlePop(location);\\n    }\\n  };\\n\\n  var handlePop = function handlePop(location) {\\n    if (forceNextPop) {\\n      forceNextPop = false;\\n      setState();\\n    } else {\\n      var action = 'POP';\\n\\n      transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {\\n        if (ok) {\\n          setState({ action: action, location: location });\\n        } else {\\n          revertPop(location);\\n        }\\n      });\\n    }\\n  };\\n\\n  var revertPop = function revertPop(fromLocation) {\\n    var toLocation = history.location;\\n\\n    // TODO: We could probably make this more reliable by\\n    // keeping a list of paths we've seen in sessionStorage.\\n    // Instead, we just default to 0 for paths we don't know.\\n\\n    var toIndex = allPaths.lastIndexOf(createPath(toLocation));\\n\\n    if (toIndex === -1) toIndex = 0;\\n\\n    var fromIndex = allPaths.lastIndexOf(createPath(fromLocation));\\n\\n    if (fromIndex === -1) fromIndex = 0;\\n\\n    var delta = toIndex - fromIndex;\\n\\n    if (delta) {\\n      forceNextPop = true;\\n      go(delta);\\n    }\\n  };\\n\\n  // Ensure the hash is encoded properly before doing anything else.\\n  var path = getHashPath();\\n  var encodedPath = encodePath(path);\\n\\n  if (path !== encodedPath) replaceHashPath(encodedPath);\\n\\n  var initialLocation = getDOMLocation();\\n  var allPaths = [createPath(initialLocation)];\\n\\n  // Public interface\\n\\n  var createHref = function createHref(location) {\\n    return '#' + encodePath(basename + createPath(location));\\n  };\\n\\n  var push = function push(path, state) {\\n    warning(state === undefined, 'Hash history cannot push state; it is ignored');\\n\\n    var action = 'PUSH';\\n    var location = createLocation(path, undefined, undefined, history.location);\\n\\n    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {\\n      if (!ok) return;\\n\\n      var path = createPath(location);\\n      var encodedPath = encodePath(basename + path);\\n      var hashChanged = getHashPath() !== encodedPath;\\n\\n      if (hashChanged) {\\n        // We cannot tell if a hashchange was caused by a PUSH, so we'd\\n        // rather setState here and ignore the hashchange. The caveat here\\n        // is that other hash histories in the page will consider it a POP.\\n        ignorePath = path;\\n        pushHashPath(encodedPath);\\n\\n        var prevIndex = allPaths.lastIndexOf(createPath(history.location));\\n        var nextPaths = allPaths.slice(0, prevIndex === -1 ? 0 : prevIndex + 1);\\n\\n        nextPaths.push(path);\\n        allPaths = nextPaths;\\n\\n        setState({ action: action, location: location });\\n      } else {\\n        warning(false, 'Hash history cannot PUSH the same path; a new entry will not be added to the history stack');\\n\\n        setState();\\n      }\\n    });\\n  };\\n\\n  var replace = function replace(path, state) {\\n    warning(state === undefined, 'Hash history cannot replace state; it is ignored');\\n\\n    var action = 'REPLACE';\\n    var location = createLocation(path, undefined, undefined, history.location);\\n\\n    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {\\n      if (!ok) return;\\n\\n      var path = createPath(location);\\n      var encodedPath = encodePath(basename + path);\\n      var hashChanged = getHashPath() !== encodedPath;\\n\\n      if (hashChanged) {\\n        // We cannot tell if a hashchange was caused by a REPLACE, so we'd\\n        // rather setState here and ignore the hashchange. The caveat here\\n        // is that other hash histories in the page will consider it a POP.\\n        ignorePath = path;\\n        replaceHashPath(encodedPath);\\n      }\\n\\n      var prevIndex = allPaths.indexOf(createPath(history.location));\\n\\n      if (prevIndex !== -1) allPaths[prevIndex] = path;\\n\\n      setState({ action: action, location: location });\\n    });\\n  };\\n\\n  var go = function go(n) {\\n    warning(canGoWithoutReload, 'Hash history go(n) causes a full page reload in this browser');\\n\\n    globalHistory.go(n);\\n  };\\n\\n  var goBack = function goBack() {\\n    return go(-1);\\n  };\\n\\n  var goForward = function goForward() {\\n    return go(1);\\n  };\\n\\n  var listenerCount = 0;\\n\\n  var checkDOMListeners = function checkDOMListeners(delta) {\\n    listenerCount += delta;\\n\\n    if (listenerCount === 1) {\\n      addEventListener(window, HashChangeEvent, handleHashChange);\\n    } else if (listenerCount === 0) {\\n      removeEventListener(window, HashChangeEvent, handleHashChange);\\n    }\\n  };\\n\\n  var isBlocked = false;\\n\\n  var block = function block() {\\n    var prompt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\\n\\n    var unblock = transitionManager.setPrompt(prompt);\\n\\n    if (!isBlocked) {\\n      checkDOMListeners(1);\\n      isBlocked = true;\\n    }\\n\\n    return function () {\\n      if (isBlocked) {\\n        isBlocked = false;\\n        checkDOMListeners(-1);\\n      }\\n\\n      return unblock();\\n    };\\n  };\\n\\n  var listen = function listen(listener) {\\n    var unlisten = transitionManager.appendListener(listener);\\n    checkDOMListeners(1);\\n\\n    return function () {\\n      checkDOMListeners(-1);\\n      unlisten();\\n    };\\n  };\\n\\n  var history = {\\n    length: globalHistory.length,\\n    action: 'POP',\\n    location: initialLocation,\\n    createHref: createHref,\\n    push: push,\\n    replace: replace,\\n    go: go,\\n    goBack: goBack,\\n    goForward: goForward,\\n    block: block,\\n    listen: listen\\n  };\\n\\n  return history;\\n};\\n\\nexport default createHashHistory;\"]}","code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[8],{16:function(t,n,o){\"use strict\";var e=o(3),i=o.n(e),a=o(6),r=o.n(a),c=o(4),s=o(2),u=o(8),f=o(5),h=\"function\"==typeof Symbol&&\"symbol\"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&\"function\"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?\"symbol\":typeof t},l=Object.assign||function(t){for(var n=1;n<arguments.length;n++){var o=arguments[n];for(var e in o)Object.prototype.hasOwnProperty.call(o,e)&&(t[e]=o[e])}return t},d=function(){try{return window.history.state||{}}catch(t){return{}}};n.a=function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};r()(f.b,\"Browser history needs a DOM\");var n=window.history,o=Object(f.g)(),e=!Object(f.h)(),a=t.forceRefresh,p=void 0!==a&&a,b=t.getUserConfirmation,w=void 0===b?f.c:b,y=t.keyLength,v=void 0===y?6:y,g=t.basename?Object(s.g)(Object(s.a)(t.basename)):\"\",O=function(t){var n=t||{},o=n.key,e=n.state,a=window.location,r=a.pathname+a.search+a.hash;return i()(!g||Object(s.c)(r,g),'You are attempting to use a basename on a page whose URL path does not begin with the basename. Expected path \"'+r+'\" to begin with \"'+g+'\".'),g&&(r=Object(s.e)(r,g)),Object(c.a)(r,e,o)},j=function(){return Math.random().toString(36).substr(2,v)},m=Object(u.a)(),k=function(t){l(Y,t),Y.length=n.length,m.notifyListeners(Y.location,Y.action)},P=function(t){Object(f.d)(t)||T(O(t.state))},S=function(){T(O(d()))},L=!1,T=function(t){L?(L=!1,k()):m.confirmTransitionTo(t,\"POP\",w,function(n){n?k({action:\"POP\",location:t}):x(t)})},x=function(t){var n=Y.location,o=H.indexOf(n.key);-1===o&&(o=0);var e=H.indexOf(t.key);-1===e&&(e=0);var i=o-e;i&&(L=!0,M(i))},E=O(d()),H=[E.key],B=function(t){return g+Object(s.b)(t)},M=function(t){n.go(t)},R=0,U=function(t){1===(R+=t)?(Object(f.a)(window,\"popstate\",P),e&&Object(f.a)(window,\"hashchange\",S)):0===R&&(Object(f.e)(window,\"popstate\",P),e&&Object(f.e)(window,\"hashchange\",S))},C=!1,Y={length:n.length,action:\"POP\",location:E,createHref:B,push:function(t,e){i()(!(\"object\"===(void 0===t?\"undefined\":h(t))&&void 0!==t.state&&void 0!==e),\"You should avoid providing a 2nd state argument to push when the 1st argument is a location-like object that already has state; it is ignored\");var a=Object(c.a)(t,e,j(),Y.location);m.confirmTransitionTo(a,\"PUSH\",w,function(t){if(t){var e=B(a),r=a.key,c=a.state;if(o)if(n.pushState({key:r,state:c},null,e),p)window.location.href=e;else{var s=H.indexOf(Y.location.key),u=H.slice(0,-1===s?0:s+1);u.push(a.key),H=u,k({action:\"PUSH\",location:a})}else i()(void 0===c,\"Browser history cannot push state in browsers that do not support HTML5 history\"),window.location.href=e}})},replace:function(t,e){i()(!(\"object\"===(void 0===t?\"undefined\":h(t))&&void 0!==t.state&&void 0!==e),\"You should avoid providing a 2nd state argument to replace when the 1st argument is a location-like object that already has state; it is ignored\");var a=Object(c.a)(t,e,j(),Y.location);m.confirmTransitionTo(a,\"REPLACE\",w,function(t){if(t){var e=B(a),r=a.key,c=a.state;if(o)if(n.replaceState({key:r,state:c},null,e),p)window.location.replace(e);else{var s=H.indexOf(Y.location.key);-1!==s&&(H[s]=a.key),k({action:\"REPLACE\",location:a})}else i()(void 0===c,\"Browser history cannot replace state in browsers that do not support HTML5 history\"),window.location.replace(e)}})},go:M,goBack:function(){return M(-1)},goForward:function(){return M(1)},block:function(){var t=arguments.length>0&&void 0!==arguments[0]&&arguments[0],n=m.setPrompt(t);return C||(U(1),C=!0),function(){return C&&(C=!1,U(-1)),n()}},listen:function(t){var n=m.appendListener(t);return U(1),function(){U(-1),n()}}};return Y}},17:function(t,n,o){\"use strict\";o(3),o(6),o(4);var e=o(2);o(8),o(5),Object.assign,e.f,e.a,e.a,e.a}}]);","extractedComments":[]}